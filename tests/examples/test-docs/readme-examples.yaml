hello-world:
  input:
    name: world
    message: Hello ))name!

  output:
    name: world
    message: Hello world!

string-values:
  input:
    server:
      host: 127.0.0.1
      port: 8080
    app:
      api_url: http://)){server/host}:)){server/port}/api
      greeting: Welcome, ))user!
      # String values can be sliced
      mask: )){server/host}[:3].x.x.x
    user: Alice
  output:
    server:
      host: 127.0.0.1
      port: 8080
    app:
      api_url: http://127.0.0.1:8080/api
      greeting: Welcome, Alice!
      mask: 127.x.x.x
    user: Alice

path-values:
  input:
    project-name: my-project
    work-dir: /mnt/work
    tmpfs-dir:
      )){work-dir}/tmpfs
    tmpfs-2-dir:
      ))work-dir//tmpfs
    tmp-dir:
      )){tmpfs-dir}/))project-name
    tmp-2-dir:
      ))tmpfs-dir//))project-name
    log-dir:
      )){tmpfs-dir}/logs
    log-2-dir:
      ))tmpfs-dir//logs
  output:
    project-name: my-project
    work-dir: /mnt/work
    tmpfs-dir:
      /mnt/work/tmpfs
    tmpfs-2-dir:
      /mnt/work/tmpfs
    tmp-dir:
      /mnt/work/tmpfs/my-project
    tmp-2-dir:
      /mnt/work/tmpfs/my-project
    log-dir:
      /mnt/work/tmpfs/logs
    log-2-dir:
      /mnt/work/tmpfs/logs

keys:
  input:
    a-key:
      A_VALUE
    )){a-key}-key:
      A_VALUE_2
    )){A_VALUE-key}-key:
      A_VALUE_3
    b-key:
      c-key:
        C_VALUE
    )){b-key/c-key}-key:
      C_VALUE_2
    key-d:
      key-e:
        ))a-key:
          A Deep Value
    key-f:
      key-g:
        ))c-key:
          A Deeper Value
    key-h:
      key-i:
        )){b-key/c-key}:
          A Deeper Value by keychain
    key-j:
      ))a-key:
        key-x:
          X
        key-y:
          Y

  output:
    a-key:
      A_VALUE
    A_VALUE-key:
      A_VALUE_2
    A_VALUE_2-key:
      A_VALUE_3
    b-key:
      c-key:
        C_VALUE
    C_VALUE-key:
      C_VALUE_2
    key-d:
      key-e:
        A_VALUE:
          A Deep Value
    key-f:
      key-g:
        C_VALUE:
          A Deeper Value
    key-h:
      key-i:
        C_VALUE:
          A Deeper Value by keychain
    key-j:
      A_VALUE:
        key-x:
          X
        key-y:
          Y
ats:
  input:
    config:

      a-key:
        ))@
      b-key:
        B_VALUE
      c-key:
        ))b-key
      d-key:
        The full name of this key is )){@}
      e-key:
        f-key:
          The short name of this key is ))@
        g-key: |
          This key is called both ))@ and )){@} depending
          on how the at variable is used.
      h-key:
        l-key: |
          this key's parent is ))@[-1] and it must work
          in multiline mode.
        m-key:
          this key's parent's parent is ))@[-2]
      g-key:
        i-key:
          the full name of this key's parent is )){@[-1]}
        j-key:
          k-key: |
            the full name of this key's parent's parent is )){@[-2]}
            and it must work in multiline mode.
        n-key:
          - this key is the ))@ key
          - this key's parent is the ))@[-1] key
          - this key's parent's parent is the ))@[-2] key
          - this key has a dash after it ))@[-1]-
      linux:
        version: 6.4.12
        vVx: v6.x
        ext: xz
        fetch-urls:
          - https://cdn.kernel.org/pub/))@[-1]/kernel/)){))@[-1]/vVx}/))@[-1]-)){))@[-1]/version}.tar.)){))@[-1]/ext}
      # This can be a useful idiom for complex configurations when a value is undefined; the trailing slash here is required
      project-type:
        ))))@/

  output:
    config:
      a-key:
        a-key
      b-key:
        B_VALUE
      c-key:
        B_VALUE
      d-key:
        The full name of this key is config/d-key
      e-key:
        f-key:
          The short name of this key is f-key
        g-key: |
          This key is called both g-key and config/e-key/g-key depending
          on how the at variable is used.
      h-key:
        l-key: |
          this key's parent is h-key and it must work
          in multiline mode.
        m-key:
          this key's parent's parent is config
      g-key:
        i-key:
          the full name of this key's parent is config/g-key
        j-key:
          k-key: |
            the full name of this key's parent's parent is config/g-key
            and it must work in multiline mode.
        n-key:
          - this key is the n-key key
          - this key's parent is the g-key key
          - this key's parent's parent is the config key
          - this key has a dash after it g-key-
      linux:
        version: 6.4.12
        vVx: v6.x
        ext: xz
        fetch-urls:
          - https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.4.12.tar.xz
      project-type:
        ))project-type/
ifs:
  input:
    settings:
      debug_mode: true
      log_level: ))?{debug_mode :DEBUG :INFO}
    # Note the ))@ use to specify the settings-2/debug_mode key
    # Otherwise settings/debug_mode is selected by the depth-first rule for ambiguous keys
    settings-2:
      debug_mode: n
      log_level: ))?{ ! ))@[-1]/debug_mode :INFO :DEBUG}

    a:
      f: A
      g: hello
    b: B
    c: |
      some multiline
      text
    d: False
    e: ))?{ b == a/f & 'hello' == a/g :c :'I am False' }
    # You can use an empty case for the false condition; returns an empty string
    f: ))?{ b != a/f & 'hello' == a/g :'I am True' }
    g: ))?{ b == a/f & 'hello' == a/g :'I am True' }
    h: ))?{ b  !=  a/f  &  'hello'  ==  a/g  :'I am True'  :'I am False'  }
    i: ))?{ b == a/f | 'hello' == a/g :c :d }

  output:
    settings:
      debug_mode: true
      log_level: DEBUG
    settings-2:
      debug_mode: n
      log_level: INFO
    a:
      f: A
      g: hello
    b: B
    c: |
      some multiline
      text
    d: False
    e: I am False
    f: I am True
    g: ''
    h: I am True
    i: |
      some multiline
      text

ifs-keys:
  input:
    is-a: y
    some-data: hello
    more-data: goodbye
    # A trailing slash trims the root key of the case
    ))?{is-a}/:
      yes:
        my-yes-data: yes
      no:
        my-no-data: no
    # No trailing slash preserves the root key of the case
    ))?{!is-a}:
      yes:
        my-yes-data: yes
      no:
        my-no-data: no
    even-more-data: hohum
    a-string:
      hello
    # Slicing is permitted in comparisons
    ))?{a-string[:-1] == 'hell'}/:
      yes:
        correct:
          1
      no:
        incorrect:
          0
    enable_monitoring: false
    # This entire block will be removed from the output
    ))?{enable_monitoring}:
      monitoring:
        endpoint: http://monitor.svc.cluster.local
        port: 9090

  output:
    is-a: y
    some-data: hello
    more-data: goodbye
    my-yes-data: yes
    no:
      my-no-data: no
    even-more-data: hohum
    a-string:
      hello
    correct:
      1
    enable_monitoring: false

imports:
  input:
    config:
      # Paths are relative to the current file
      ))+some-data:
        ./data/tree-data.yaml#uu
      ))+some-more-data:
        ./data/more-tree-data.yaml#uu/
  output:
    config:
      uu:
        vv: VV
        ww: WW
      vv: VV
      ww: WW
plaintext:
  input:
    config:
      a-key: A_VALUE
      some-plaintext-data:
        ./data/a-plain-file#
  output:
    config:
      a-key: A_VALUE
      some-plaintext-data: |
        Here is some plain text.

        # its structure should be preserved as a multi-line value under a key in a YAML file
        A_VALUE = 1000


        /dev/nvme0n1p1          /boot           vfat            noauto,noatime  1 2
